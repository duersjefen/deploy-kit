import fs from 'fs-extra';
import * as path from 'path';
import * as os from 'os';
import chalk from 'chalk';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// ESM equivalent of __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Setup Claude Code for the Web (CCW) integration
 * Idempotent - can run multiple times to update
 *
 * Follows official CCW best practices:
 * - Uses .claude/ directory (official location)
 * - Creates .claude/settings.json with SessionStart hooks
 * - Auto-installs dependencies on session start
 * - Uses CLAUDE_CODE_REMOTE detection
 * - Uses @ sourcing pattern in CLAUDE.md
 */
export async function setupCCW(projectRoot: string = process.cwd()): Promise<void> {
  console.log(chalk.bold.cyan('\nüîß Setting up Claude Code for the Web (CCW)\n'));

  const claudeDir = path.join(projectRoot, '.claude');
  const claudeScriptsDir = path.join(claudeDir, 'scripts');

  // 1. Copy global CLAUDE.md to .claude/
  await copyGlobalClaudeMd(claudeDir);

  // 2. Copy ccw.md template if it doesn't exist
  await copyCcwMdTemplate(claudeDir);

  // 3. Create .claude/scripts/ directory
  await fs.ensureDir(claudeScriptsDir);

  // 4. Create SessionStart hook script in .claude/scripts/
  await createSessionStartScript(claudeScriptsDir);

  // 5. Create .claude/settings.json with hooks
  await createSettingsJson(claudeDir, claudeScriptsDir);

  // 6. Ensure .claude/ is not ignored in .gitignore
  await ensureClaudeDirNotIgnored(projectRoot);

  // 7. Update project CLAUDE.md
  await updateProjectClaudeMd(projectRoot, claudeDir);

  // 7. Detect and output required tokens
  const requiredTokens = await detectRequiredTokens(projectRoot);
  outputTokenList(requiredTokens);

  // 8. Output CCW usage instructions
  outputUsageInstructions();

  console.log(chalk.green('\n‚úÖ CCW setup complete!\n'));
}

/**
 * Copy ~/.claude/CLAUDE.md to .claude/global_claude.md
 * This gets committed to git and copied to ~/.claude/CLAUDE.md on CCW server
 */
async function copyGlobalClaudeMd(claudeDir: string): Promise<void> {
  const globalClaudePath = path.join(os.homedir(), '.claude', 'CLAUDE.md');
  const targetPath = path.join(claudeDir, 'global_claude.md');

  if (!await fs.pathExists(globalClaudePath)) {
    console.log(chalk.yellow('‚ö†Ô∏è  ~/.claude/CLAUDE.md not found - skipping global rules'));
    return;
  }

  await fs.ensureDir(claudeDir);
  await fs.copy(globalClaudePath, targetPath);
  console.log(chalk.green('‚úÖ Copied ~/.claude/CLAUDE.md ‚Üí .claude/global_claude.md'));
}

/**
 * Copy ccw.md template from deploy-kit (always overwrites to get latest patterns)
 * This provides comprehensive API patterns for GitHub and Linear
 */
async function copyCcwMdTemplate(claudeDir: string): Promise<void> {
  const targetPath = path.join(claudeDir, 'ccw.md');

  // ccw.md is in the project root's .claude directory
  // When built, dist is in project root, so we go up to find .claude/ccw.md
  const templatePath = path.join(__dirname, '..', '..', '..', '.claude', 'ccw.md');

  if (!await fs.pathExists(templatePath)) {
    console.log(chalk.yellow('‚ö†Ô∏è  ccw.md template not found in deploy-kit'));
    console.log(chalk.yellow('     Expected location: .claude/ccw.md'));
    console.log(chalk.dim(`     Tried: ${templatePath}`));
    return;
  }

  await fs.ensureDir(claudeDir);
  await fs.copy(templatePath, targetPath, { overwrite: true });
  console.log(chalk.green('‚úÖ Copied ccw.md template ‚Üí .claude/ccw.md (GitHub/Linear API patterns)'));
}

/**
 * Create .claude/scripts/setup_ccw.sh with SessionStart hook logic
 * This runs automatically when CCW session starts
 */
async function createSessionStartScript(scriptsDir: string): Promise<void> {
  await fs.ensureDir(scriptsDir);

  const setupScript = `#!/bin/bash
# Auto-generated by deploy-kit ccw
# SessionStart hook for Claude Code for the Web
# Runs automatically when CCW session starts

# Only run in CCW cloud environment (not locally)
if [ "$CLAUDE_CODE_REMOTE" != "true" ]; then
  echo "‚ÑπÔ∏è  Skipping CCW setup (running locally)"
  exit 0
fi

# Don't exit on errors - handle them gracefully
set +e

# Get project directory (use CLAUDE_PROJECT_DIR if set, otherwise use PWD)
PROJECT_DIR="\${CLAUDE_PROJECT_DIR:-$PWD}"

echo "üîß Setting up Claude Code for the Web environment..."
echo "üìÇ Project: $PROJECT_DIR"

# Copy global CLAUDE.md to ~/.claude/CLAUDE.md
if [ -f "$PROJECT_DIR/.claude/global_claude.md" ]; then
  mkdir -p ~/.claude
  cp "$PROJECT_DIR/.claude/global_claude.md" ~/.claude/CLAUDE.md
  echo "‚úÖ Global CLAUDE.md copied to ~/.claude/CLAUDE.md"
else
  echo "‚ö†Ô∏è  No .claude/global_claude.md found (run 'dk ccw' locally to create)"
fi

# Append CCW-specific instructions to project CLAUDE.md
# This keeps CLAUDE.md clean in git for local/Desktop users
# while CCW users get environment-specific instructions at runtime
if [ -f "$PROJECT_DIR/.claude/ccw.md" ] && [ -f "$PROJECT_DIR/CLAUDE.md" ]; then
  echo "" >> "$PROJECT_DIR/CLAUDE.md"
  echo "---" >> "$PROJECT_DIR/CLAUDE.md"
  echo "" >> "$PROJECT_DIR/CLAUDE.md"
  cat "$PROJECT_DIR/.claude/ccw.md" >> "$PROJECT_DIR/CLAUDE.md"
  echo "‚úÖ CCW instructions appended to CLAUDE.md (runtime only)"
else
  if [ ! -f "$PROJECT_DIR/.claude/ccw.md" ]; then
    echo "‚ö†Ô∏è  .claude/ccw.md not found - CCW instructions not available"
  fi
fi

# Check for jq (JSON processor)
if ! command -v jq &> /dev/null; then
  echo "‚ö†Ô∏è  jq not available (requires root to install)"
else
  echo "‚úÖ jq available"
fi

# Check for required tools
if [ -n "$GITHUB_TOKEN" ]; then
  echo "‚úÖ GITHUB_TOKEN available (.claude/scripts/gh_helper.sh)"
else
  echo "‚ö†Ô∏è  GITHUB_TOKEN not set - GitHub operations limited"
fi

if [ -n "$LINEAR_API_KEY" ]; then
  echo "‚úÖ LINEAR_API_KEY available (.claude/scripts/linear_helper.sh)"
else
  echo "‚ö†Ô∏è  LINEAR_API_KEY not set - Linear operations limited"
fi

# Install project dependencies (package.json if exists)
if [ -f "$PROJECT_DIR/package.json" ]; then
  echo "üì¶ Installing project dependencies..."
  cd "$PROJECT_DIR" || exit 1

  # Detect package manager
  if [ -f "pnpm-lock.yaml" ]; then
    if pnpm install 2>&1 | grep -v "WARN"; then
      echo "‚úÖ Dependencies installed (pnpm)"
    else
      echo "‚ö†Ô∏è  Some dependencies may have failed to install"
    fi
  elif [ -f "yarn.lock" ]; then
    if yarn install 2>&1 | grep -v "warning"; then
      echo "‚úÖ Dependencies installed (yarn)"
    else
      echo "‚ö†Ô∏è  Some dependencies may have failed to install"
    fi
  elif [ -f "bun.lockb" ]; then
    if bun install 2>&1; then
      echo "‚úÖ Dependencies installed (bun)"
    else
      echo "‚ö†Ô∏è  Some dependencies may have failed to install"
    fi
  else
    if npm install 2>&1 | grep -v "WARN"; then
      echo "‚úÖ Dependencies installed (npm)"
    else
      echo "‚ö†Ô∏è  Some dependencies may have failed to install"
    fi
  fi
fi

# Install Python dependencies if requirements.txt exists
if [ -f "$PROJECT_DIR/requirements.txt" ]; then
  echo "üì¶ Installing Python dependencies..."
  if pip install -r "$PROJECT_DIR/requirements.txt" 2>&1 | tail -1; then
    echo "‚úÖ Python dependencies installed"
  else
    echo "‚ö†Ô∏è  Some Python dependencies may have failed to install"
  fi
fi

# Persist environment variables for session (if CLAUDE_ENV_FILE is set)
if [ -n "$CLAUDE_ENV_FILE" ]; then
  # Write npm token to npmrc if NPM_TOKEN is set
  if [ -n "$NPM_TOKEN" ]; then
    if echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > ~/.npmrc 2>/dev/null; then
      echo "NPM_CONFIGURED=true" >> "$CLAUDE_ENV_FILE"
      echo "‚úÖ npm token configured"
    else
      echo "‚ö†Ô∏è  Failed to configure npm token"
    fi
  fi
fi

echo ""
echo "‚úÖ CCW environment setup complete!"
echo ""
echo "Available CLI tools:"
if [ -n "$GITHUB_TOKEN" ]; then
  echo "  ‚úÖ .claude/scripts/gh_helper.sh (GitHub operations)"
else
  echo "  ‚ö†Ô∏è  .claude/scripts/gh_helper.sh (needs GITHUB_TOKEN)"
fi
if [ -n "$LINEAR_API_KEY" ]; then
  echo "  ‚úÖ .claude/scripts/linear_helper.sh (Linear operations)"
else
  echo "  ‚ö†Ô∏è  .claude/scripts/linear_helper.sh (needs LINEAR_API_KEY)"
fi
if [ -n "$NPM_TOKEN" ] && [ -f ~/.npmrc ]; then
  echo "  ‚úÖ npm authentication configured"
fi

exit 0
`;

  const setupPath = path.join(scriptsDir, 'setup_ccw.sh');
  await fs.writeFile(setupPath, setupScript);
  await fs.chmod(setupPath, 0o755);

  console.log(chalk.green('‚úÖ Created .claude/scripts/setup_ccw.sh (SessionStart hook)'));
}

/**
 * Create .claude/scripts/gh_helper.sh - GitHub CLI wrapper with curl fallback
 * Auto-detects gh CLI availability and falls back to GitHub API
 */
async function createGitHubHelper(scriptsDir: string): Promise<void> {
  const helperPath = path.join(scriptsDir, 'gh_helper.sh');

  // Try to read from .claude/scripts/ folder (the committed source)
  const sourceHelperPath = path.join(process.cwd(), '.claude', 'scripts', 'gh_helper.sh');
  if (await fs.pathExists(sourceHelperPath)) {
    await fs.copy(sourceHelperPath, helperPath);
    await fs.chmod(helperPath, 0o755);
    console.log(chalk.green('‚úÖ Created .claude/scripts/gh_helper.sh (GitHub CLI wrapper)'));
  } else {
    console.log(chalk.yellow('‚ö†Ô∏è  gh_helper.sh template not found'));
    console.log(chalk.yellow('     Run from published package or ensure .claude/scripts/gh_helper.sh exists'));
  }
}

/**
 * Create .claude/scripts/linear_helper.sh - Linear GraphQL API wrapper
 * Simple CLI tool for Linear operations without MCP
 */
async function createLinearHelper(scriptsDir: string): Promise<void> {
  const helperPath = path.join(scriptsDir, 'linear_helper.sh');

  // Try to read from .claude/scripts/ folder (the committed source)
  const sourceHelperPath = path.join(process.cwd(), '.claude', 'scripts', 'linear_helper.sh');
  if (await fs.pathExists(sourceHelperPath)) {
    await fs.copy(sourceHelperPath, helperPath);
    await fs.chmod(helperPath, 0o755);
    console.log(chalk.green('‚úÖ Created .claude/scripts/linear_helper.sh (Linear CLI wrapper)'));
  } else {
    console.log(chalk.yellow('‚ö†Ô∏è  linear_helper.sh template not found'));
    console.log(chalk.yellow('     Run from published package or ensure .claude/scripts/linear_helper.sh exists'));
  }
}

/**
 * Create .claude/settings.json with SessionStart hooks
 * Uses $CLAUDE_PROJECT_DIR for portability
 */
async function createSettingsJson(claudeDir: string, scriptsDir: string): Promise<void> {
  await fs.ensureDir(claudeDir);

  const settings = {
    permissions: {
      allow: ['Bash'],
    },
    hooks: {
      SessionStart: [
        {
          matcher: 'startup',
          hooks: [
            {
              type: 'command',
              command: '"$CLAUDE_PROJECT_DIR/.claude/scripts/setup_ccw.sh"',
            },
          ],
        },
      ],
    },
  };

  const settingsPath = path.join(claudeDir, 'settings.json');
  await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2));

  console.log(chalk.green('‚úÖ Created .claude/settings.json (auto-runs setup on session start)'));
}

/**
 * Ensure .claude/ is not ignored in .gitignore
 * These files should be committed as they contain project-wide CCW configuration
 */
async function ensureClaudeDirNotIgnored(projectRoot: string): Promise<void> {
  const gitignorePath = path.join(projectRoot, '.gitignore');

  if (!await fs.pathExists(gitignorePath)) {
    console.log(chalk.gray('   No .gitignore found - .claude/ will be tracked by default'));
    return;
  }

  let gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
  const lines = gitignoreContent.split('\n');
  let modified = false;

  // Look for lines that ignore .claude/ directory
  const updatedLines = lines.map(line => {
    const trimmed = line.trim();
    // Check for .claude/ patterns (with or without trailing slash, with or without leading dot)
    if (trimmed === '.claude' || trimmed === '.claude/' || trimmed === '/.claude' || trimmed === '/.claude/') {
      modified = true;
      // Comment it out instead of removing (preserve user's intent but make it inactive)
      return `# ${line} # Commented by dk ccw - .claude/ should be tracked for CCW config`;
    }
    return line;
  });

  if (modified) {
    await fs.writeFile(gitignorePath, updatedLines.join('\n'));
    console.log(chalk.green('‚úÖ Removed .claude/ from .gitignore (CCW files should be tracked)'));
  } else {
    console.log(chalk.gray('   .claude/ not in .gitignore - will be tracked ‚úì'));
  }
}

/**
 * Update project CLAUDE.md with CCW info (optional)
 * No longer adds sourcing pattern - global rules are copied to ~/.claude/CLAUDE.md on CCW server
 */
async function updateProjectClaudeMd(projectRoot: string, claudeDir: string): Promise<void> {
  const claudeMdPath = path.join(projectRoot, 'CLAUDE.md');

  if (!await fs.pathExists(claudeMdPath)) {
    console.log(chalk.yellow('‚ö†Ô∏è  CLAUDE.md not found - skipping update'));
    return;
  }

  // No changes needed - project CLAUDE.md stays clean with only project-specific instructions
  // Global rules are handled by copying .claude/global_claude.md ‚Üí ~/.claude/CLAUDE.md on CCW server
  console.log(chalk.gray('   CLAUDE.md remains project-specific (global rules handled by CCW setup)'));
}

/**
 * Detect which tokens are required
 */
async function detectRequiredTokens(projectRoot: string): Promise<string[]> {
  const tokens: string[] = ['GITHUB_TOKEN', 'LINEAR_API_KEY'];

  // Check if npm package (needs NPM_TOKEN)
  const packageJsonPath = path.join(projectRoot, 'package.json');
  if (await fs.pathExists(packageJsonPath)) {
    const packageJson = await fs.readJson(packageJsonPath);
    if (packageJson.publishConfig || packageJson.name?.startsWith('@')) {
      tokens.push('NPM_TOKEN');
    }
  }

  return tokens;
}

/**
 * Output list of required tokens
 */
function outputTokenList(tokens: string[]): void {
  console.log('\nRequired CCW environment variables:');
  console.log(chalk.gray('‚îÅ'.repeat(60)));

  for (const token of tokens) {
    const hint = getTokenHint(token);
    console.log(`${chalk.cyan(token.padEnd(25))} ${chalk.gray(hint)}`);
  }

  console.log(chalk.gray('‚îÅ'.repeat(60)));
  console.log(chalk.yellow('\nNote: For deployments, use Desktop Claude Code or GitHub Actions.'));
  console.log(chalk.yellow('      CCW is for feature development, refactoring, and testing only.'));
}

/**
 * Get hint for where to find token
 */
function getTokenHint(token: string): string {
  switch (token) {
    case 'GITHUB_TOKEN':
      return '(gh auth token)';
    case 'LINEAR_API_KEY':
      return '(https://linear.app/settings/api)';
    case 'NPM_TOKEN':
      return '(cat ~/.npmrc | grep _authToken)';
    default:
      return '';
  }
}

/**
 * Output CCW usage instructions
 */
function outputUsageInstructions(): void {
  console.log('\nHow to use CCW:');
  console.log(chalk.gray('‚îÅ'.repeat(60)));
  console.log(chalk.white(`
1. Go to claude.ai/code
2. Connect your GitHub account
3. Set environment variables in CCW:
   - GITHUB_TOKEN (required for GitHub operations)
   - LINEAR_API_KEY (required for Linear operations)
   - NPM_TOKEN (if publishing packages)

4. Select this repository
5. Start working - setup runs automatically!

The SessionStart hook will:
  ‚úÖ Copy global CLAUDE.md to ~/.claude/CLAUDE.md
  ‚úÖ Auto-install project dependencies
  ‚úÖ Configure npm for publishing
  ‚úÖ Provide CLI tools in .claude/scripts/

Available CLI tools:
  ‚Ä¢ .claude/scripts/gh_helper.sh - GitHub operations (PR, merge, etc.)
  ‚Ä¢ .claude/scripts/linear_helper.sh - Linear operations (get/list/update issues)

Usage examples:
  bash .claude/scripts/gh_helper.sh pr create --title "..." --body "..."
  bash .claude/scripts/linear_helper.sh get-issue DEP-21
  bash .claude/scripts/linear_helper.sh list-issues

All features work immediately - no reopen required!
`));
  console.log(chalk.gray('‚îÅ'.repeat(60)));
}
